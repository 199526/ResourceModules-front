name: 'Deploy dependencies'
description: 'Deploy dependencies'

inputs:
  templateFilePath:
    description: 'The path to the template file to use for deployment'
    required: true
  parameterFilePath:
    description: 'The path to the parameter file to use for deployment'
    required: true
  location:
    description: 'The location to use for deployment'
    required: true
  resourceGroupName:
    description: 'The resource group to deploy to'
    required: false
  subscriptionId:
    description: 'The subscriptionId to deploy to'
    required: false
  managementGroupId:
    description: 'The managementGroupId to deploy to'
    required: false

runs:
  using: 'composite'
  steps:
    - name: 'Setup agent'
      shell: pwsh
      run: |
        # Load used functions
        . (Join-Path $env:GITHUB_WORKSPACE 'utilities' 'pipelines' 'sharedScripts' 'Set-EnvironmentOnAgent.ps1')

        # Set agent up
        Set-EnvironmentOnAgent

    - name: Azure Login
      uses: Azure/login@v1
      with:
        creds: ${{ env.AZURE_CREDENTIALS }}
        enable-AzPSSession: true

    - name: 'Deploy dependencies for template [${{ inputs.templateFilePath }}]'
      shell: pwsh
      id: deploy_step
      run: |
        # Load used functions
        . (Join-Path $env:GITHUB_WORKSPACE 'utilities' 'pipelines' 'resourceDeployment' 'New-ModuleDeployment.ps1')

        $namespacePath = Split-Path '${{ inputs.templateFilePath }}'.TrimStart('arm') -Parent
        $templateFileName = '{0}.bicep' -f (Split-Path '${{ inputs.parameterFilePath }}' -LeafBase)
        $dependencyTemplateFilePath = Join-Path $env:GITHUB_WORKSPACE 'utilities' 'pipelines' 'moduleDependencies' $namespacePath $templateFileName

        if(-not (Test-Path $dependencyTemplateFilePath)) {
          Write-Verbose "No dependency deployment found in path [$dependencyTemplateFilePath]. Skipping deployment" -Verbose
          return
        }

        $functionInput = @{
          templateFilePath   = $dependencyTemplateFilePath
          location           = '${{ inputs.location }}'
          resourceGroupName  = '${{ inputs.resourceGroupName }}'
          subscriptionId     = '${{ inputs.subscriptionId }}'
          managementGroupId  = '${{ inputs.managementGroupId }}'
        }

        Write-Verbose "Invoke task with" -Verbose
        Write-Verbose ($functionInput | ConvertTo-Json | Out-String) -Verbose

        # Invoke deployment
        $res = New-ModuleDeployment @functionInput -Verbose

        # Get deployment name
        if($res -is [hashtable]) {
          $deploymentName = $res['DeploymentName']
        } elseif($res -is [string]) {
          $deploymentName = $res
        } else {
          throw ("Output-Type of New-ModuleDeployment invocation has invalid type [{0}]" -f $res.GetType())
        }
        Write-Output ('::set-output name=deploymentName::{0}' -f $deploymentName)

        if($res -is [hashtable]) {
          # Happens only if there is an exception
          throw $res['Exception']
        }
